def calc(expression):
    #Evaluates valid mathematical expressions with -+*/() and whitespace.  
    #API restriction prevents the use of eval() and exec()
    #TODO, edge cases involving negative numbers cause some kind of error.  Look into that.  
    
    #helper
    def pseudo_eva(n1, n2, sym):    
        #Due to API restrictions, this is the best way I can think to translate the symbols to an operation
        if sym == "+":
            return n1 + n2
        elif sym == "-":
            return n1 - n2
        elif sym == "*":
            return n1 * n2
        elif sym == "/":
            return n1 / n2
    
    # remove whitespace for easier parsing
    expression = expression.replace(" ", "")
    
    # recursively evaluate all expressions in parentheses
    while "(" in expression:
        left_index = expression.index("(")
        right_index = left_index
        is_opn = -1

        # expression is opn until we've seen as many closing parentheses as we have opn ones.
        while is_opn:
            right_index += 1
            c = expression[right_index]
            if c == "(":
                is_opn += -1
            elif c == ")":
                is_opn += 1
        left_index += 1

        n_expression = expression[left_index:right_index]
        expression = expression[:left_index - 1] + str(calc(n_expression)) + expression[right_index + 1:]

    #convert expression to list of numbers and symbols
    numbers = []
    syms = []
    running_n = ""
    is_first = True
    for c in expression:
        if c == "-" and is_first:
            running_n = c
            is_first = False
            continue
        is_first = False
        if c.isnumeric():
            running_n += c
        else:
            numbers.append(int(running_n))
            syms.append(c)
            running_n = ""
            is_first = True
    else:
        numbers.append(int(running_n))
    
    #TODO, DRIP THIS TOGETHER   
    while "*" in syms or "/" in syms:
        #brute force find first index of * or /
        i = 0
        while not (syms[i] == "*" or syms[i] == "/"):
            i += 1
        sym = syms.pop(i)
        n1 = numbers.pop(i)
        n2 = numbers.pop(i)
        
        numbers.insert(i, pseudo_eva(n1, n2, sym))
        
    while "+" in syms or "-" in syms:
        #brute force find first index of + or -
        i = 0
        while not (syms[i] == "+" or syms[i] == "-"):
            i += 1
        sym = syms.pop(i)
        n1 = numbers.pop(i)
        n2 = numbers.pop(i)
        
        numbers.insert(i, pseudo_eva(n1, n2, sym))

    return numbers[0]
