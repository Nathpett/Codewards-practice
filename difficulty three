def hand(hole_cards, community_cards):
    #Given hand and community cards for Texas Hold'em, returns the type of hand and a list of tiebreaking card ranks.
    SUITS = "♣♦♥♠"
    RANKS = "AKQJT98765432"

    is_straight = False
    is_flush = False
    is_straight_flush = False
    
    pool = hole_cards + community_cards
    pool = [c if len(c) < 3 else "T" + c[-1] for c in pool]
    pool.sort(key = lambda card: RANKS.index(card[0]))
    
    #Idenify hand type
    seq_streak = 1 #Tracks running straight
    last_p_rank = pool[0][0] 
    high_straight_rank = None #Tracks highest rank of straight if any
    
    p_streak = 1 #Tracks running streak of last_rank
    max_p_streak = 0 #Tracks highest streak of atleast one pair, used to determine full house / two pair
    dict_pair = {} #saves all pairs by rank.  used to full house and two pairs
    for c in pool[1:]:
        #change pair variables
        if c[0] == last_p_rank:
            p_streak += 1
        else:
            #reset streak
            if p_streak > 1:
                dict_pair[last_p_rank] = p_streak
                if p_streak > max_p_streak:
                    max_p_streak = p_streak
            p_streak = 1
            
            #straight isn't broken with duplicates, only gaps, so check here
            if RANKS.index(c[0]) == RANKS.index(last_p_rank) + 1:
                seq_streak += 1
                if seq_streak == 5: 
                    high_straight_rank = RANKS[RANKS.index(c[0]) - 4]
                    is_straight = True
            else:
                seq_streak = 1
        last_p_rank = c[0]
    #Gotta repeat here since ending the list counts as breaking the streak
    if p_streak > 1:
        dict_pair[c[0]] = p_streak
        if p_streak > max_p_streak:
            max_p_streak = p_streak
    
    #determine whether flush
    just_suits = [c[1] for c in pool]
    for suit in SUITS:
        if just_suits.count(suit) >= 5:
            is_flush = True
            flush_suit = suit
    
    #Determine whether any of our flushes are straight flushes
    if is_flush:
        only_flush_suits = [RANKS.index(c[0]) for c in pool if c[1] == flush_suit] #List of rank's indexs for all cards in pool belonging to the flush suit
        seq_streak = 0
        highest_rank = RANKS[only_flush_suits[0]]
        i = 0
        
        while i < len(only_flush_suits) - 1:
            if only_flush_suits[i] == only_flush_suits[i + 1] - 1:
                seq_streak += 1
            elif only_flush_suits[i] != only_flush_suits[i + 1]:
                seq_streak = 0
                highest_rank = RANKS[only_flush_suits[i + 1]]
            if seq_streak == 4:
                is_straight_flush = True
                high_straight_rank = highest_rank
                break
            i += 1
    
    #construct list of ordered ranks in pool, used for constructing tiebreakers    
    just_ranks = []
    for c in pool:
        if c[0] not in just_ranks:
            just_ranks.append(c[0])
        
    #construct list of tuples (f, r) for all pairs/of-a-kind with f being frequency of the rank, and r the rank's index in RANKS, ordered first by their frequency, then their rank.  
    #Then just convert those tuples to the ranks because that's all we need!
    #e.g., ["A♠", "K♦", "K♣", "K♥", "A♥", "Q♥", "3♦"] will be [K, A], as K is more frequent.  
    # we use this to construct tiebreakers where multipule pairs exist
    if max_p_streak > 1:
        ordered_pair_ranks = [(-dict_pair[r], RANKS.index(r)) for r in dict_pair.keys()]
        ordered_pair_ranks.sort()
        ordered_pair_ranks = [RANKS[tuple[1]] for tuple in ordered_pair_ranks]
    
    if max_p_streak == 4:
        hand = "four-of-a-kind"
        tiebreaker = [ordered_pair_ranks[0]]
        just_ranks.remove(tiebreaker[0])
        tiebreaker += just_ranks[0]
    elif is_straight_flush:
        hand = "straight-flush"
        straight_start = just_ranks.index(high_straight_rank)
        tiebreaker = [r for r in just_ranks[straight_start:straight_start + 5]]
    elif max_p_streak == 3 and len(dict_pair.keys()) > 1:
        hand = "full house"
        tiebreaker = ordered_pair_ranks[:2]
    elif is_flush:
        hand = "flush"
        tiebreaker = [c[0] for c in pool if c[1] == flush_suit][:5]
    elif is_straight:
        hand = "straight"
        straight_start = just_ranks.index(high_straight_rank)
        tiebreaker = [r for r in just_ranks[straight_start:straight_start + 5]]
    elif max_p_streak == 3:
        hand = "three-of-a-kind"
        tiebreaker = [list(dict_pair.keys())[0]]
        just_ranks.remove(tiebreaker[0])
        tiebreaker += just_ranks[:2]
    elif len(dict_pair.keys()) > 1:
        hand = "two pair"
        tiebreaker = ordered_pair_ranks[:2]
        for r in tiebreaker:
            just_ranks.remove(r)
        tiebreaker += just_ranks[0]
    elif len(dict_pair.keys()) == 1:
        hand = "pair"
        tiebreaker = [list(dict_pair.keys())[0]]
        just_ranks.remove(tiebreaker[0])
        tiebreaker += just_ranks[:3]
    else:
        hand = "nothing"
        tiebreaker = [c[0] for c in pool[:5]]
    
    #replace 'T' with '10' in tiebreaker haha
    for i, r in enumerate(tiebreaker):
        if r == "T":
            tiebreaker[i] = "10"
    
    return (hand, tiebreaker)
