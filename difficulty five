import math

def hex_string_to_RGB(s): 
    RGB = "rgb"
    HEX = {"A":10, "B":11, "C":12, "D":13, "E":14, "F":15}
    def hex_didget_to_decimal(d):    
        if d in HEX.keys():
            return HEX[d]
        else:
            return int(d)
    s = s.upper()
    r = {}
    for i in range(3):
        color = s[2*i+1:2*i+3]
        color = hex_didget_to_decimal(color[0]) * 16 + hex_didget_to_decimal(color[1])
        r[RGB[i]] = color
    return r
    
def order_weight(s):
    #Weight being the sum of a number's didgets, and then prioritized by alphabetical order
    def get_weight(n):
        w = 0
        sw = 0
        i = 1
        for c in n:
            w += int(c)
            sw += (int(c)+1)/(10**i)
            i += 1
        return (w, sw)
    l = s.split(" ")
    l.sort(key=get_weight)
    return " ".join(l)


def productFib(prod):
    fib = {0:0, 1:1}
    def get_fib(n):
        if n in fib.keys():
            return fib[n]
        new_fib = get_fib(n-1) + get_fib(n-2)
        fib[n] = new_fib
        return new_fib
    
    i = 0
    while get_fib(i) * get_fib(i+1) < prod:
        i += 1
    return [get_fib(i), get_fib(i+1), get_fib(i) * get_fib(i+1) == prod]

# encodes/decodes decimal to str in factorial numbering system
# see https://en.wikipedia.org/wiki/Factorial_number_system
ALP = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
def dec_2_fact_string(nb):
    s = ""
    for i in range(36, -1, -1):
        cur_didget = 0
        while math.factorial(i) <= nb:
            nb -= math.factorial(i)
            cur_didget += 1
        s += ALP[cur_didget]
    while s[0] == '0':
        s = s [1:] 
    return s

def fact_string_2_dec(s):
    n = 0
    for i in range(0, len(s)):
        c = s[len(s) - (i + 1)]
        n += math.factorial(i) * ALP.index(c)
    return n


def perimeter(n):
    #returns perimeter of all squares of length 0 to n + 1 in the fibonacci sequence
    def get_fib(n):
        #overwrite values to avoid huge memory usuage and recursion depth excess 
        a, b = 0, 1
        while n != 0:
            a, b = a + b, a
            n -= 1
        return a
    return 4 * (get_fib(n + 3) - 1)

def greed_dice_score(dice):
    #Returns score of five six sided dice rolls for the game Greed 
    r = 0
    dice.sort()
    for n in set(dice):
        if dice.count(n) >= 3:
            if n == 1:
                r += 1000
            else:
                r += n * 100
            for i in range(3):
                dice.remove(n)
    for n in dice:
        if n == 1:
            r += 100
        if n == 5:
            r += 50
    return r

#Create a string of an integer's prime decomposition
def prime_factors(n):
    prime = 2
    primes = get_prime()
    decomp = {2: 0}
    while not is_prime(n):
        if n % prime == 0:
            n = n // prime
            decomp[prime] += 1
        else:
            prime = next(primes)
            decomp[prime] = 0
    
    if n in decomp.keys():
        decomp[n] += 1
    else:
        decomp[n] = 1

    bases = [base for base in decomp.keys() if decomp[base] != 0]
    bases.sort()
    s = ""
    for base in bases:
        if decomp[base] == 1:
            s += f'({base})'
        else:
            s += f'({base}**{decomp[base]})'
    return s


    def get_prime():
        n = 2
        while True:
            n += 1
            while not is_prime(n):
                n += 1
            yield n


    def is_prime(n):
        for i in range(2, int(n / 2) + 1):
            if n % i == 0:
                return False
        return True



def get_k(n):
#helper for consec_kprimes
    def get_prime():
        n = 2
        while True:
            n += 1
            while not is_prime(n):
                n += 1
            yield n

    def is_prime(n):
        for i in range(2, int(n / 2) + 1):
            if n % i == 0:
                return False
        return True
    
    prime = 2
    primes = get_prime()
    decomp = {2: 0}
    while not is_prime(n):
        if n % prime == 0:
            n = n // prime
            decomp[prime] += 1
        else:
            prime = next(primes)
            decomp[prime] = 0
    
    if n in decomp.keys():
        decomp[n] += 1
    else:
        decomp[n] = 1

    expo = list(decomp.values())
    return sum(expo)


def consec_kprimes(k, arr):
    #given k and array of numbers, returns number of instances where k prime numbers in arr appear twice in a row
    k_arr = [get_k(p) for p in arr]
    con_ct = 0
    for i, p in enumerate(k_arr[:-1]):
        if p == k_arr[i + 1] == k:
            con_ct += 1
    return con_ct
    
    
def make_readable(ss):
    #Takes time in seconds up to 359999 and returns human readable time in HH:MM:SS format
    hh = ss // (60 * 60)
    ss -= hh * (60 * 60)
    mm = ss // 60
    ss -= mm * 60
    return f"{str(hh).rjust(2, '0')}:{str(mm).rjust(2, '0')}:{str(ss).rjust(2, '0')}"


def page_digits(pages):
    #Returns sum of didgets of all pages in a book of given length
    didget_ct = len(str(pages))   
    n = 0
    for i in range(0, didget_ct - 1):
        n += 9 * (10**i) * (i + 1)
    if didget_ct > 1:
        past_page_ct = int("9"* (didget_ct - 1))
    else:
        past_page_ct = 0
    n += didget_ct * (pages - past_page_ct)
    return n
    
from math import ceil
def odd_sequence(arr):
    #WIP
    #Returns number of sequences in arr with an odd number of odd numbers.  Harder than it sounds, still working on it
    extreme_odd_index_left = 0
    extreme_odd_index_right = len(arr) - 1
    
    arr = [n % 2 == 1 for n in arr]
    if arr.count(True) == 0:
        return 0
    extreme_odd_index_left = arr.index(True)
    extreme_odd_index_right = len(arr) - list(reversed(arr)).index(True)
    
    base_len = 1 + extreme_odd_index_right - extreme_odd_index_left
    base = ((base_len) // 2) ** 2

    if base_len % 2 == 1:
        base += base_len // 2
    
    if extreme_odd_index_left != 0 and extreme_odd_index_right != len(arr):
        return "AA"
    
    if extreme_odd_index_right != 0:
        end_len = extreme_odd_index_left
        base += len(arr) // 2 * end_len
    
    if extreme_odd_index_right != len(arr):
        end_len = len(arr) - 1 - extreme_odd_index_right
        base += len(arr) // 2 * end_len
        
    return base
    
def number_to_english(n):
    #Returns number up to 99,999 in written english
    if n == 0: return "zero"
    if n > 99999 or n < 0 or not isinstance(n, int): 
        return ""
    ones = {"1":"one", "2":"two", "3":"three", "4":"four", "5":"five", "6":"six", "7":"seven", "8":"eight", "9":"nine"}
    tens = {"1":"ten", "2": "twenty", "3": "thirty", "4": "forty", "5": "fifty", "6":"sixty", "7":"seventy", "8":"eighty", "9":"ninety"}
    exceptions = {"11":"eleven", "12": "twelve", "13":"thirteen", "14":"fourteen", "15":"fifteen", "16":"sixteen", "17":"seventeen", "18":"eighteen", "19":"nineteen"}
    
    def number_to_english_3_didget(n):
        s = ""
        if n[0] != "0":
            s += ones[n[0]] + " hundred"
        
        if n[1] != "0":
            if n[1:] in exceptions:
                s += " " + exceptions[n[1:]]
                return s
            else:
                s += " " + tens[n[1]]
        
        if n[2] != "0":
            s += " " + ones[n[2]]
        return s.strip()
    
    n = str(n)
    if len(n) > 3:
        hundreds = number_to_english_3_didget(n[-3:])
        s = number_to_english_3_didget(n[:-3].rjust(3, "0")) + " thousand " + hundreds
    else:
        s = number_to_english_3_didget(n.rjust(3, "0"))
    return s.strip()
