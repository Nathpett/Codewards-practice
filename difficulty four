def get_pins(observed):
    #brute force guesses a pin pad given seed values as potential ranges.  Returns list of all possible combinations given observed pin pad input offset by atleast one key horizontally or vertically.
    PIN_PAD = ["123", "456", "789", " 0 "]
    def get_potential_pins(c):
        #return string of all pins offset by 1 horizontal or vertical move on a pin pad, and also the seed pin c
        pins = ""
        pins += c
        for i in range(len(PIN_PAD)):
            row = PIN_PAD[i]
            if c in row:
                # horizontal pins
                h_index = row.index(c)
                if h_index != len(row) - 1:
                    pins += row[h_index + 1]
                if h_index != 0:
                    pins += row[h_index - 1]
                
                # vertical pins
                # i == v_index
                if i != len(PIN_PAD) - 1:
                    pins += PIN_PAD[i + 1][h_index]
                if i != 0:
                    pins += PIN_PAD[i - 1][h_index]
                    
                #delete "blank" pins
                pins = pins.replace(" ", "")
                
                return pins
    
    potential_pins = []
    for c in observed:
        potential_pins.append(get_potential_pins(c))
    
    r = set()
    index_list = [0] * len(potential_pins)
    while True:
        cur_combo = ""
        for i in range(len(potential_pins)):
            cur_index = index_list[i]
            cur_combo += potential_pins[i][cur_index]
        r.add(cur_combo)

        i = 0
        index_list[i] += 1
        while index_list[i] == len(potential_pins[i]):
            index_list[i] = 0
            i += 1
            if i == len(potential_pins):
                return list(r)
            index_list[i] += 1
            
    return r

def next_bigger(n):
    #returns the next biggest number that can be made using the given number's didgets
    #returns -1 if input is already the biggest number that can be made
    
    n = list(str(n))
    for i in range(len(n)):
        r = n[-1-i:]
        if r == sorted(r, reverse=True):
            continue
        highest_place = r[0]
        higher = [v for v in r if int(v) > int(highest_place)]
        next_largest = min(higher)
        r.remove(next_largest)
        return int("".join(n[:-1-i] + [next_largest] + sorted(r, reverse=False)))
    return -1
        
        
def knight(p1, p2):
    #returns minimum number of moves a knight in chess can make between two positions on a chess board
    #input is given as 'a1', 'h8', etc.
    
    #Going to use Breadth First Search.
    #node = column + row * 8
        #where row = ROWS.index(p[1])
        #and column = COLS.index(p[0])
    COLS = 'abcdefgh'
    ROWS = '12345678'
    K_MOVES = [-17, -15, -10, -6, 6, 10, 15, 17] 
    
    n0 = COLS.index(p1[0]) + 8 * ROWS.index(p1[1])
    nd = COLS.index(p2[0]) + 8 * ROWS.index(p2[1])
    
    visited = [None] * 64
    queue = [n0]
    
    found = False
    while queue and not found:
        n = queue.pop(0)
        n_col = n % 8
        valid_moves = [n + offset for offset in K_MOVES]
        valid_moves = [e for e in valid_moves if (0 <= e <= 63) and n_col - 2 <= (e % 8) <= n_col + 2]
        for e in valid_moves:
            if e == nd:
                found = True
            if visited[e] == None:
                visited[e] = n
                queue.append(e)

    #Traverse parents starting at nd to get to n0.
    series = [nd]
    while n0 not in series:
        n = series[-1]
        series.append(visited[n])
    
    return len(series) - 1

def valid_sudoku(board):
    #validates sudoku board, returns false if any 0s
    #board is a list of lists of length 9
    
    def simple_validate(_list):
        for row in _list:
            if sum(row) != 45:
                return False
            for i in range(1, 9):
                if row.count(i) != 1:
                    return False
        return True
    
    cells = [[] for i in range(9)]
    columns = [[] for i in range(9)]
    for i, row in enumerate(board):
        for j, n in enumerate(row):
            if n == 0:
                return False
            columns[j].append(n)
            cells[i//3 + 3 * (j//3)].append(n)
    
    return simple_validate(board) and simple_validate(cells) and simple_validate(columns)
