def high(x):
    #returns word with highest "score", score the sum of a word's characters' index + 1 in the alphabet
    alp = 'abcdefghijklmnopqrstuvwxyz'
    def get_index_score(w):
        score = 0
        for c in w:
            score += alp.index(c) + 1
        return score
    
    champ = 0
    for word in x.split(" "):
        cur_score = get_index_score(word)
        if cur_score > champ:
            champ = cur_score
            champ_word = word
    return champ_word



def dig_pow(n, p):
    #returns k if any, where k is: (a ^ p + b ^ (p+1) + c ^(p+2) + d ^ (p+3) + ...) = n * k <abcd... being each didget in n>
    s = 0
    for i, d in enumerate(str(n)):
        d = int(d)
        s += d**(p + i)
    if s % n == 0:
        return s//n
    else:
        return -1


def bishop(start_pos, end_pos, num_moves):
    returns whether a bishop in chess can reach end_pos from start_pos given some number of moves num_moves
    row_l = "12345678"
    col_l = "abcdefgh"

    y, x = start_pos
    y, x = col_l.index(y), row_l.index(x)
    yy, xx = end_pos
    yy, xx = col_l.index(yy), row_l.index(xx)
    return ((x + y) % 2 == (xx + yy) % 2) \
           and ((num_moves == 0 and start_pos == end_pos) \
           or (num_moves == 1 and abs(x - xx) == abs(y - yy)) \
           or (num_moves >= 2))
           

def tower_builder(n_floors, brick = "*", space = " "):
    #returns pyramid of n_floors height
    return [(n_floors - 1 - i) * space + (i * 2 + 1) * brick + (n_floors - 1 - i) * space for i in range(n_floors)]
    
def likes(names):
    #given list of names, returns short summary of those who like it.
    l = len(names)
    if l == 0:
        return 'no one likes this'
    elif l == 1:
        return f'{names[0]} likes this'
    elif l == 2:
        return f'{names[0]} and {names[1]} like this'
    elif l == 3:
        return f'{names[0]}, {names[1]} and {names[2]} like this'
    else:
        return f'{names[0]}, {names[1]} and {str(l - 2)} others like this'

def last_survivors(string):
    #substitute two equal letters by the next letter of the alphabet until no further substitutions can be made
    ALPHA = "abcdefghijklmnopqrstuvwxyza"
    _list = list(string)
    z_repeat = True
    
    while z_repeat:
        for c in ALPHA[:-1]:
            while _list.count(c) > 1:
                _list.remove(c)
                _list.remove(c)
                _list += ALPHA[ALPHA.index(c) + 1]
        else:
            z_repeat = _list.count('a') > 1
    return "".join(_list)


def decode(r):
    #decodes string encoding using following pseudocode
    #encode("mer", 6015)  -->  "6015ekx"
    # for each char in string, multiply index in ALPHA by n, take modulo, and use result as index in ALPHA for new encoded value

    ALPHA = "abcdefghijklmnopqrstuvwxyz"
    
    c = "0"
    i = 0
    while c.isnumeric():
        c = r[i]
        i += 1
    i -= 1
    
    n = int(r[:i])
    s = r[i:]
    
    step = n % 26
    
    if step % 2 == 0 or step == 13:
        return "Impossible to decode"
    
    decode_key = [step * i % 26 for i in range(26)]
    sd = ''
    for c in s:
        i = ALPHA.index(c)
        sd += ALPHA[decode_key.index(i)]
    return sd

def uncollapse(digits):
    #Takes string of written out single didget numbers without spaces, returns with spaces
    # "fourfiveeightninenine" ==> "four five eight nine nine" 
    NUMS = ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "zero"]
    s = []
    while digits:
        i = 0
        while digits[:i] not in NUMS:
            i += 1
        s.append(digits[:i])
        digits = digits[i:]
    return " ".join(s)
    
def encode_v1(text):
    #swaps 2nd and last letter, replaces first letter with its character code
    s = []
    if len(text) < 2: return text
    for word in text.split(" "):
        word = list(word)
        if len(word) > 1:
            word[-1], word[1] = word[1], word[-1]
        word[0] = str(ord(word[0]))
        s.append("".join(word))
    return " ".join(s)
